package wirogen

import scala.meta._
import org.scalafmt.Scalafmt
import org.scalafmt.config._
import org.scalafmt.rewrite._

import scala.collection.JavaConverters._

import java.nio.file.Path
import java.nio.file.Paths
import java.nio.file.Files

object Main {
  def main(args: Array[String]): Unit = {
    Files
      .newDirectoryStream(Paths.get("src", "main", "scala", "rps", "controller"))
      .asScala
      .filterNot(p => Files.isDirectory(p))
      .foreach { path =>
        val warning = "// This file is automatically generated. DO NOT EDIT MANUALLY\n\n"
        val content = warning + processFile(path)
        val fileName = path.getFileName.toString.replace("Controller", "Routes")
        val outputPath = Paths.get("src", "main", "scala", "rps", "routes", fileName)
        Files.write(outputPath, content.getBytes());
      }
  }

  def processFile(path: Path): String = {
    val bytes = Files.readAllBytes(path)
    val text = new String(bytes, "UTF-8")
    val input = Input.VirtualFile(path.toString, text)
    val source = input.parse[Source].get

    val (controllerName, queries, commands): (Name, List[Decl.Def], List[Decl.Def]) =
      source.collect {
        case q"..$mods trait $tname[..$tparams] extends $template" =>
          val queries = template.collect {
            case m @ Decl.Def(mods, _, _, _, _)
                if mods.exists(_.structure == mod"@query".structure) =>
              m
          }
          val commands = template.collect {
            case m @ Decl.Def(mods, _, _, _, _)
                if mods.exists(_.structure == mod"@command".structure) =>
              m
          }
          (tname, queries, commands)
      }.head

    val endpoints = queries.map(processQuery) ++ commands.map(processCommand)

    val routesName = Type.Name(controllerName.toString.replace("Controller", "Routes"))
    val controllerType = Type.Apply(Type.Name(controllerName.toString), List(Type.Name("F")))
    val routes = q"""
      package rps {

      import cats.implicits._
      import cats.effect._
      import org.http4s._
      import org.http4s.dsl.Http4sDsl
      import io.circe.Decoder
      import io.circe.JsonObject
      import io.buildo.enumero.circe._
      import org.http4s.circe.CirceEntityDecoder._
      import org.http4s.circe.CirceEntityEncoder._

      class $routesName[F[_]: Sync](controller: $controllerType) extends Http4sDsl[F] {

        private def extractFromBody[A: Decoder](json: JsonObject, name: String): Option[A] =
          json(name).flatMap(_.as[A].toOption)

        val routes: HttpRoutes[F] = HttpRoutes.of[F] {
          ..case $endpoints
        }

      }
    }
    """

    Scalafmt
      .format(
        routes.syntax,
        ScalafmtConfig.default
          .copy(
            maxColumn = 100,
            rewrite = RewriteSettings(List(PreferCurlyFors)),
            newlines = Newlines(alwaysBeforeTopLevelStatements = true))
      )
      .get
  }

  def processQuery(query: Decl.Def): scala.meta.Case =
    query match {
      case q"..$mods def $ename[..$tparams](...$paramss): $tpe" =>
        val body = q"""for {
          result <- controller.$ename()
          res <- Ok(result)
        } yield res"""
        val name = Lit.String(ename.toString)
        p"case GET -> Root / $name => $body"
    }

  def processCommand(command: Decl.Def): scala.meta.Case =
    command match {
      case q"..$mods def $ename[..$tparams](...$paramss): $tpe" =>
        val params = paramss.head
        val extractParams = params.map { param =>
          val n = Lit.String(param.name.toString)
          val p = Pat.Var(Term.Name(param.name.toString))
          enumerator"$p <- extractFromBody[${param.decltpe.get}](jsonBody, $n)"
        }
        val body = q"""for {
          jsonBody <- req.as[JsonObject]
          result <- (for {
            ..$extractParams
          } yield controller.$ename(..${params.map(p => Term.Name(p.name.toString))}))
          .map(Ok(_)).getOrElse(BadRequest())
        } yield result"""
        val name = Lit.String(ename.toString)
        p"case req @ POST -> Root / $name => $body"
    }
}
